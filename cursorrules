# Project Name: TabTalk AI: Conversational Web Assistant

# Project Goal: Build a Chrome extension that allows users to chat with AI (Google Gemini) about the content of the current webpage.

# Core Functionality:
# 1. Content Extraction: Extract main text content from the active tab.
# 2. AI Interaction: Send extracted content + user query to Google Gemini API via a background script.
# 3. User Interface: Provide a chat interface in the popup.
# 4. API Key Management: Securely store and use the user's Gemini API key.

# Key Files and their Roles:
# - manifest.json: Defines the extension's properties, permissions (activeTab, storage, scripting), host permissions (for Gemini API), entry points (popup, background, content scripts), and icons.
# - popup.html: The HTML structure for the extension's popup interface.
# - popup.css: Styles the popup interface for a modern, chat-like look.
# - popup.js: Handles the popup's logic. This includes UI interactions (button clicks, input handling), managing the chat display, sending messages to content/background scripts, receiving responses, handling settings (API key input, save, remove), and managing the onboarding flow.
#   - Key functions in popup.js: `init`, `bindEvents`, `loadSettings`, `saveSettings`, `checkApiKeyAndShowInterface`, `updatePageInfo`, `extractPageContent` (DEPRECATED - real extraction moved to content.js), `handleQuickAction`, `handleInputChange`, `updateSendButton`, `sendMessage`, `getRealPageContent` (sends message to content script), `callGeminiAPI` (sends message to background script), `addMessage`, `createMessageControls`, `formatMessage` (basic markdown), `addLoadingMessage`, `copyMessage`, `saveMessage`, `deleteMessage`, `clearChat`, `showToast`, `removeApiKey`, `handleOnboardingDisplay`. Also includes `TabTalkOnboarding` class for the onboarding flow.
# - background.js: Runs as a service worker in the background. Handles installation, stores API key using `chrome.storage.local`, and makes the actual HTTP requests to the Google Gemini API. It listens for messages from the popup.
#   - Key functions in background.js: `handleGeminiAPI` (retrieves key, formats prompt with page content + user message, makes fetch request to Gemini API, sends response back to popup).
# - content.js: Runs on every webpage (as defined in manifest.json). Its main purpose is to extract the readable content from the page. It listens for messages from the popup.
#   - Key functions in content.js: `extractPageContent` (implements the logic to find, filter, clean, and truncate page text), `getPageInfo`, `highlightTextInPage`, `removeExistingHighlights`, `escapeRegExp`. Includes mutation observer to detect URL changes for SPAs.
# - icons/: Folder containing extension icons.
# - marked.min.js: A client-side library used in popup.js for formatting markdown in AI responses.

# Data Flow:
# 1. User opens popup -> popup.js starts.
# 2. popup.js checks for API key (in chrome.storage.local) and shows onboarding or chat interface.
# 3. If chat is shown, popup.js sends a message to content.js (`action: 'extractPageContent'`) to get page content.
# 4. content.js extracts content from the current tab and sends it back to popup.js.
# 5. popup.js receives page content.
# 6. User types a message and clicks send in popup.
# 7. popup.js takes user message and stored page content (or gets it again if needed/failed previously).
# 8. popup.js sends a message to background.js (`action: 'callGeminiAPI'`) including the user message and page content.
# 9. background.js receives the message, retrieves the API key from storage, constructs the prompt, makes a fetch request to the Google Gemini API.
# 10. background.js receives the API response and sends it back to popup.js.
# 11. popup.js receives the AI response, formats it (using marked.min.js), adds it to the chat display, and scrolls to the bottom.

# Key Dependencies/Libraries:
# - Google Gemini API (via fetch in background.js)
# - marked.min.js (for markdown formatting in popup.js)
# - Chrome Extension APIs (`chrome.runtime`, `chrome.tabs`, `chrome.storage.local`, `chrome.action`)

# Current State & Context:
# - The project uses a standard Chrome Extension architecture.
# - API key is handled via a gamified onboarding flow and settings panel in the popup.
# - Content extraction logic is implemented in content.js with filtering and truncation.
# - Communication between popup, content, and background scripts relies heavily on `chrome.runtime.sendMessage`.
# - Basic markdown formatting is applied to AI responses.
# - Error handling for content extraction and API calls has been partially implemented.
# - The project includes a README.md, popup.html, popup.css, popup.js, background.js, content.js, manifest.json, icons/, and marked.min.js.
# - We recently fixed a syntax error in content.js and added more robust response handling in popup.js's `getRealPageContent` function.

# Important Considerations/Rules for Assistant:
# - Always remember the three main parts of the extension (popup, content, background) and how they communicate.
# - When making code changes, be mindful of which script you are modifying and its role in the overall architecture.
# - Do not hallucinate or invent functionality that doesn't exist in the provided code (e.g., server-side components, databases).
# - All persistent data (like API key) is stored using `chrome.storage.local`. Chat history is session-only within the popup.
# - API calls MUST be made from the background script (`background.js`) due to security restrictions and best practices for Chrome Extensions.
# - Content extraction MUST be done in the content script (`content.js`) as it has access to the webpage's DOM.
# - UI updates and user input handling MUST be done in the popup script (`popup.js`).
# - Be aware of the character limits for content extraction (~25k) and API prompts (~8k) when discussing functionality.
# - The project uses `marked.min.js` for markdown, so no complex markdown features should be assumed unless supported by this library.
# - Always propose changes using the `edit_file` tool and cite the file and line numbers correctly.
# - When discussing errors, refer to the specific file and function involved based on the stack trace provided.
# - Remember the user's current context (open files, cursor position) but rely primarily on the project structure and file contents for information.
# - If asked to add new features, propose them in the context of this existing architecture and identify which file(s) would need modification.
# - The README.md and this cursorrules file are the primary sources of project knowledge outside the code itself.
# - Avoid making assumptions about external services beyond the Google Gemini API and the Chrome Extension environment.
# - The project is focused on analyzing *webpage* content; do not assume capabilities for analyzing arbitrary files or local data unless explicitly added.

# This file serves as a comprehensive guide to the TabTalk AI project's structure, functionality, and constraints for the AI assistant. 